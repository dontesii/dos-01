
1) Lecture20 - task1: упростить скрипт, сделать проверку в цикле


Упрощенный скрипт 

#!/bin/bash
count=1
while [ -n "$1" ]
do 
echo "par № $count = $1" 
count=$[ $count+1 ]
shift
done
exit



2) Баш скрипт, который проверяет дисковое пространство на удаленных машинах
    1. Если больше 70 процентов - шлет на почту оповещение
    2. Если больше 80 процентов - шлет список самых больших 10 файлов по размеру
    3. Если больше 90 процентов - удаляет файлы из var/log - топ 5

Баш скрип работает через команду cat scr.sh | ssh rab2@192.168.122.200


#!/bin/bash
#ssh  rab2@192.168.122.200  
min=0.70
sre=0.80
max=0.90
spc=$(df -k -BG  | grep "/dev/sda6" |  awk '{print ($2-$3)/100}')    
if (( $(echo "$spc > $min" |bc -l) )); then
echo "Занято больше  "$spc"" | mail -s "Свободного места " roooootac@mail.ru 
if (( $(echo "$spc > $sre" |bc -l) )); then
find . -mount -type f -size +512M -print 2>/dev/null | xargs -r -d '\n' ls -lh | sort -k5,5 -h -r | mail -s "Свободного места " roooootac@mail.ru 
if (( $(echo "$spc > $max" |bc -l) )); then
find var/log -type f -exec du -Sh {} + | sort -rh | head -n 5 | rm -rf {}
fi




3) Bash trap
Встроенная команда trap, которая может перехватывать такие команды и выполнять какие-либо действия, заданные ей.
Синтаксис команды:
trap command signals
command — что именно необходимо выполнить при перехвате сигнала;
signals — список сигналов, которые необходимо перехватывать.
Сигналы можно указывать как в полном виде — SIGTERM, так и в виде кода — 1, 2 и т.д.

Простейший пример 

Рассмотрим простой пример скрипта, в котором цикл будет выполняться до тех пор, пока не получит сигнал Ctrl+C (SIGINT — interrupt) или не достигнет значения 100 для переменной $count:

01
$ cat trap-1.sh
#!/bin/bash

count=0
trap 'echo "Exit"; exit 1' 2
while [ $count -lt 100 ]
do
sleep 1
(( count++ ))
echo $count
done
Про циклы читайте в статье BASH: описание циклов for, while, until и примеры использования.

Пример его выполнения:


$ ./trap-1.sh
1
2
3
Exit
После получения сигнала SIGINT (Ctrl+C) trap выполнил команду 'echo "Exit"' и сразу за ней — "exit 1", 
завершив работу скрипта. В этом примере сигнал, который надо перехватить задан в виде кода — SIGINT = 2 и т.д.


Обработка ошибок
set -e
Он немедленно остановит ваш script, если простую команду не удастся.
 Я думаю, что это должно было быть по умолчанию: поскольку такие ошибки почти всегда означают что-то неожиданное, 
 на самом деле не "разумно" выполнять следующие команды


5) Библиотека
Библиотеки — файлы, содержащие функции, а затем использовать эти библиотеки в любых скриптах, где они нужны. 
Ключ к использованию библиотек — в команде source. Эта команда используется для подключения библиотек к скриптам.
 В результате функции, объявленные в библиотеке, становятся доступными в скрипте, в противном же случае функции из библиотек не будут доступны в области видимости других скриптов.

У команды source есть псевдоним — оператор «точка». Для того, чтобы подключить файл в скрипте, в скрипт надо добавить конструкцию такого вида:

. ./myscript

6) Как вызывать функцию из командной строки!
функцию из библиотеки можно подключить в файле .bashrc, используя команду source. 

7) Expect
Expect предоставляет набор команд, позволяющих взаимодействовать с утилитами командной строки. Вот его основные команды:

spawn — запуск процесса или программы. Например, это может быть командная оболочка, FTP, Telnet, ssh, scp и так далее.

expect — ожидание данных, выводимых программой. При написании скрипта можно указать, какого именно вывода он ждёт и как на него нужно реагировать.

send — отправка ответа. Expect-скрипт с помощью этой команды может отправлять входные данные автоматизируемой программе. Она похожа на знакомую вам команду echo в обычных bash-скриптах.

interact — позволяет переключиться на «ручной» режим управления программой.

8) Typeset внутри функции  и local 

Инструкции declare и typeset являются встроенными инструкциями (они абсолютно идентичны друг другу и являются синонимами) и предназначена для наложения ограничений на переменные. Для объявления переменной в качестве локальной используется конструкция
local x=a Для определения переменных с контролем типа
declare -r var - объявление переменной var только для чтения (аналог константы) declare -i number - объявление переменной number как целое число declare -a indices - объявление переменной indices как массива declare -f functions - выводит имя функции function_name, если она была объявлена ранее declare -x var_out - объявление переменной var_out как доступной для экспорта declare -x var=$value - объявление переменной var и присваивания значения ей одновременно declare -f - (без аргументов) выводит список ранее объявленных функций в сценарии
При инициализации оболочки Bash определяет большой набор внутренних переменных.
Отдельный класс внутренних переменных представляют собой переменные имена которых формируются специальными символами:
$0 - имя выполняемого скрипта $# - количество позиционных параметров, переданных сценарию $_ - последний аргумент предыдущей из выполнявшихся команд $? - код завершения последней команды (0 – успешно, другое – ошибка) $$ - PID текущего процесса (? следующий свободный PID) $! - PID последнего асинхронного процесса $* - все позиционные параметры, собранные в одну строку («$1x$2x…$n») $@ - все позиционные параметры, подлежащие дальнейшему разбору («$1» «$2» …«$n») здесь позиционным параметром называется строка(и) переданная скрипту в качестве параметра при запуске. Имя позиционного параметра в скрипте представляет собой натуральное число начиная с 1, например $1 $2 ... - первый, второй и так далее позиционный параметр



9) Экранирование

Экранирование -- это способ заключения в кавычки одиночного символа. Экранирующий (escape) символ () сообщает интерпретатору, что следующий за ним символ должен восприниматься как обычный символ. Специальное назначение некоторых экранированных символов :
используемых совместно с echo и sed \n перевод строки (новая строка) \r перевод каретки \t табуляция \v вертикальная табуляция \b забой (backspace) \a "звонок" (сигнал) \0xx ASCII-символ с кодом 0xx в восьмеричном виде)
Поведение символа \ сильно зависит от того экранирован ли он, ограничен ли кавычками или находится внутри конструкции подстановки команды или во вложенном документе.

10)Работа с аргументами в функции
Функции могут использовать стандартные позиционные параметры, в которые записывается то, что передаётся им при вызове. Например, имя функции хранится в параметре $0, первый переданный ей аргумент — в $1, второй — в $2, и так далее. Количество переданных функции аргументов можно узнать, обратившись к переменной $#. Аргументы передают функции, записывая их после её имени $# — вывод количества переданных аргументов; $* — вывод списка всех переданных аргументов; $@ — то же, что и $* — но каждый аргумент считается как простое слово (строка); $1 - $9 — нумерованные аргументы, в зависимости от позиции в списке.